/* Don't edit this; this code was generated by op_graph */
#include "planning/drifter/drifter_dynamics.hh"

namespace planning {
namespace drifter {
VecNd<8> StateDelta::to_vector(const StateDelta &in_grp) {
  const VecNd<8> out =
      (VecNd<8>() << (in_grp.x_vel_error), (in_grp.phi_error),
       ((in_grp.R_world_from_body_error_log)[0]),
       ((in_grp.R_world_from_body_error_log)[1]),
       ((in_grp.R_world_from_body_error_log)[2]), ((in_grp.x_world_error)[0]),
       ((in_grp.x_world_error)[1]), ((in_grp.x_world_error)[2]))
          .finished();
  return out;
}
StateDelta StateDelta::from_vector(const VecNd<8> &in_vec) {
  const VecNd<3> anon_416527 =
      (VecNd<3>() << (in_vec[5]), (in_vec[6]), (in_vec[7])).finished();
  const VecNd<3> anon_b09bdd =
      (VecNd<3>() << (in_vec[2]), (in_vec[3]), (in_vec[4])).finished();
  const StateDelta out =
      StateDelta{(in_vec[0]), (in_vec[1]), anon_b09bdd, anon_416527};
  return out;
}
Controls Controls::from_vector(const VecNd<2> &in_vec) {
  const Controls out = Controls{(in_vec[0]), (in_vec[1])};
  return out;
}
VecNd<2> Controls::to_vector(const Controls &in_grp) {
  const VecNd<2> out = (VecNd<2>() << (in_grp.a), (in_grp.phidot)).finished();
  return out;
}
State operator-(const State &a, const State &b) {
  const State difference =
      State{((a.x_vel) - (b.x_vel)), ((a.phi) - (b.phi)),
            ((a.R_world_from_body) * ((b.R_world_from_body).inverse())),
            ((a.x_world) - (b.x_world))};
  return difference;
}
State operator+(const State &a, const StateDelta &grp_b) {
  const State out = State{
      ((a.x_vel) + (grp_b.x_vel_error)), ((a.phi) + (grp_b.phi_error)),
      ((SO3::exp((grp_b.R_world_from_body_error_log))) * (a.R_world_from_body)),
      ((a.x_world) + (grp_b.x_world_error))};
  return out;
}
VecNd<8> State::compute_delta(const State &a, const State &b) {
  const State difference = a - b;
  const double x_vel_error = difference.x_vel;
  const double phi_error = difference.phi;
  const SO3 R_world_from_body_error = difference.R_world_from_body;
  const VecNd<3> R_world_from_body_error_log =
      SO3::log(R_world_from_body_error);
  const VecNd<3> x_world_error = difference.x_world;
  const StateDelta delta = StateDelta{
      x_vel_error, phi_error, R_world_from_body_error_log, x_world_error};
  const VecNd<8> out_vec = StateDelta::to_vector(delta);
  return out_vec;
}
State State::apply_delta(const State &a, const VecNd<8> &delta) {
  const StateDelta grp_b = StateDelta::from_vector(delta);
  const State out = a + grp_b;
  return out;
}
StateDot compute_qdot(const State &Q, const Controls &U, const Parameters &Z) {
  const double a = U.a;
  const VecNd<3> unit_x = VecNd<3>::UnitX();
  const double x_vel = Q.x_vel;
  const VecNd<3> vel_body = unit_x * x_vel;
  const double phi = Q.phi;
  const SO3 R_world_from_body = Q.R_world_from_body;
  const VecNd<3> vel_world = R_world_from_body * vel_body;
  const double phidot = U.phidot;
  const VecNd<3> unit_z = VecNd<3>::UnitZ();
  const VecNd<3> w = unit_z * phi;
  const StateDot Qdot = StateDot{a, phidot, w, vel_world};
  return Qdot;
}
StateDot operator*(const double h, const StateDot &K1) {
  const StateDot anon_c70ce3 = StateDot{(h * (K1.a)), (h * (K1.phidot)),
                                        (h * (K1.w)), (h * (K1.vel_world))};
  return anon_c70ce3;
}
State operator+(const State &Q, const StateDot &anon_02841e) {
  const State Q2 =
      State{((Q.x_vel) + (anon_02841e.a)), ((Q.phi) + (anon_02841e.phidot)),
            ((SO3::exp((anon_02841e.w))) * (Q.R_world_from_body)),
            ((Q.x_world) + (anon_02841e.vel_world))};
  return Q2;
}
StateDot operator+(const StateDot &anon_c70ce3, const StateDot &anon_084b0e) {
  const StateDot anon_d080ea =
      StateDot{((anon_c70ce3.a) + (anon_084b0e.a)),
               ((anon_c70ce3.phidot) + (anon_084b0e.phidot)),
               ((anon_c70ce3.w) + (anon_084b0e.w)),
               ((anon_c70ce3.vel_world) + (anon_084b0e.vel_world))};
  return anon_d080ea;
}
State rk4_integrate(const State &Q, const Controls &U, const Parameters &Z,
                    const double h) {
  const double half = 0.5;
  const double half_h = h * half;
  const StateDot K1 = compute_qdot(Q, U, Z);
  const State Q2 = Q + (half_h * (h * K1));
  const StateDot K2 = compute_qdot(Q2, U, Z);
  const State Q3 = Q + (half_h * (h * K2));
  const StateDot K3 = compute_qdot(Q3, U, Z);
  const State Q4 = Q + (h * (h * K3));
  const double two = 2.0;
  const StateDot K4 = compute_qdot(Q4, U, Z);
  const double sixth = 0.166666666667;
  const State Qn =
      Q + (sixth * (((h * K1) + (h * K4)) + (two * ((h * K2) + (h * K3)))));
  return Qn;
}
} // namespace drifter
} // namespace planning